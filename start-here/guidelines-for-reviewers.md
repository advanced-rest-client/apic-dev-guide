# Guidelines for reviewers

## Reviewing a PR

If you are a part of the team that review pull requests keep in mind that after accepting a PR and releasing the component it becomes a part of the ecosystem of components that are open source and used in multiple application \(not only the API Console!\). Reviewers should also bear this in mind when accepting other reviewers PRs. Don't expect that everyone is well rested when submitting a PR :\)

Before accepting a PR mind the following.

### **Is the proposed solution the best for performance, scalability and code complexity?**

There are multiple ways to solve one issue. Not all the ways are equally well designed. First of all, if the problem can be solved by using already existing APIs then there's no point adding a new code \(complexity and performance\). It may require to make some computations outside the component but the code should be included into the component's code base only if it benefits all.

**Examples of a bad practice.**

We made change to the `api-server-selector` component. Before the change it was listening for the API navigation event and performed some logic. The change was to add the `selectedShape` and `selectedShapeType` properties passed from a parent. These two properties however are the same as passed through the event. This event handler was not needed anymore but it was left out in the component.

Take a look at the [PR](https://github.com/PolymerElements/paper-progress/pull/45) I prepared for the Polymer components. The proposed change would make it easier to use the component for this particular use case but it would add more complexity to the code base while the solution was possible by using existing APIs.

### Does the change benefit single use case only?

It's never easy to answer this question but consider this. When a change benefit only one application \(say Anypoint Exchange\) but makes no sense for any other application, and the change can be done in the hosting application then most probably this PR should be rejected.

**Example of a bad practice**

Say a team wants to add some functionality to API Console but this functionality is relevant to Exchange only. However, there are APIs in place to configure the components to achieve the same effect. This means that Exchange should add some UI that allows the user to enter the configuration and pass this configuration to the console via properties.

### Is there a test for the change?

AMF related changes must be tested when using real AMF model. This will help us in the future when a model change \(which happens very often\) to detect any inconsistencies in the model. Unit tests are mandatory. If possible integration tests should also be included \(when I change a value in the anypoint-input added to the component's DOM, will the value on my component be updated as well?\)

**Examples of a bad practice**

* No unit tests
* No AMF computations tests made on generated by the AMF parser model

### Are docs and types updated?

This is not necessarily the most important thing but it helps with using the component while working with it. the documentation, demo page, and types declaration should be updated to reflect the change. This way after updating the component in another project a developer can get correct autocomplete and syntax highlighting.

